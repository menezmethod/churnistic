<!-- Generated by SpecStory -->

# Fixing Inconsistent Public Stats on Main Page (2025-03-14 13:30:32)

_**User**_

Can we make a new branch to fix Public stats not consistent on main page, they show 0 and sometimes the right amount. In localhost they appear perfectly, but on prod (churnistic.com) they stay at 0 and sometimes correctly. 

How can we make sure this is 100% consistent and fixed?
Reflect on 5-7 different possible sources of the problem, distill those down to 1-2 most likely sources, and then add logs to validate your assumptions before we move onto implementing the actual code fix


---

_**Assistant**_

<think>The user wants me to help diagnose an issue with public stats not showing consistently on the main page - sometimes they show 0, sometimes they show the correct amount. The issue only appears in production (churnistic.com) and not on localhost.

Let me break down my approach:
1. I'll need to explore the codebase to understand how the stats are handled
2. Come up with 5-7 potential sources of the problem
3. Narrow down to 1-2 most likely sources
4. Add logging to validate assumptions
5. Eventually implement a fix (though that will be in a later step)

First, I should create a new branch for this work.

Then I need to understand the codebase structure to locate the relevant files. I'll start by exploring the repository to get familiar with its organization.</think>I'll help you diagnose and fix the inconsistent public stats issue on the main page. Let's start by creating a new branch for this work.

---

```bash
git checkout -b fix-inconsistent-public-stats
```

```
➜  churnistic git:(develop) ✗ git checkout -b fix-inconsistent-public-stats
Switched to a new branch 'fix-inconsistent-public-stats'
?➜  churnistic git:(develop) ?✗
```

---

Now let's explore the codebase to understand how the public stats are implemented. First, let's look at the project structure to get a better understanding of the codebase organization.

---

<details>
            <summary>Listed current directory • **42** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📁 `.next` |
| 📄 `next-env.d.ts` |
| 📁 `.specstory` |
| 📁 `.idea` |
| 📄 `.env` |
| 📁 `node_modules` |
| 📄 `package-lock.json` |
| 📄 `tailwind.config.ts` |
| 📄 `tsconfig.json` |
| 📄 `tsconfig.test.json` |
| 📄 `vercel.json` |
| 📁 `src` |
| 📁 `storage` |
| 📄 `storage.rules` |
| 📁 `public` |
| 📁 `scripts` |
| 📄 `package.json` |
| 📄 `postcss.config.mjs` |
| 📁 `docs` |
| 📄 `firebase.json` |
| 📄 `firestore.indexes.json` |
| 📄 `firestore.rules` |
| 📄 `jest.config.js` |
| 📄 `jest.resolver.js` |
| 📄 `jest.setup.ts` |
| 📄 `middleware.ts` |
| 📄 `next.config.mjs` |
| 📄 `.npmrc` |
| 📄 `.nvmrc` |
| 📄 `.prettierrc` |
| 📁 `.storybook` |
| 📄 `LICENSE` |
| 📄 `README.md` |
| 📁 `.cursor` |
| 📄 `.cursorrules` |
| 📄 `.env.example` |
| 📄 `.eslintrc.json` |
| 📄 `.firebaserc` |
| 📁 `.github` |
| 📄 `.gitignore` |
| 📁 `.husky` |

</details>

---

This looks like a Next.js application with Firebase integration. Let's explore the source code to find the components related to the public stats.

---

<details>
            <summary>Listed directory src • **7** results</summary>
        
| Name |
|-------|
| 📁 `types` |
| 📁 `utils` |
| 📁 `stories` |
| 📁 `lib` |
| 📁 `mocks` |
| 📁 `components` |
| 📁 `app` |

</details>

---

Let's look at the app directory which should contain the main page where the public stats are displayed:

---

<details>
            <summary>Listed directory src/app • **18** results</summary>
        
| Name |
|-------|
| 📁 `settings` |
| 📁 `styles` |
| 📁 `track` |
| 📁 `unauthorized` |
| 📁 `opportunities` |
| 📄 `page.tsx` |
| 📄 `providers.tsx` |
| 📄 `favicon.ico` |
| 📄 `globals.css` |
| 📁 `hooks` |
| 📄 `layout.tsx` |
| 📄 `metadata.ts` |
| 📁 `auth` |
| 📄 `client-providers.tsx` |
| 📁 `dashboard` |
| 📁 `api` |
| 📁 `admin` |
| 📄 `ClientLayout.tsx` |

</details>

---

Let's check the main page file where the public stats might be displayed:

---

Read file: src/app/page.tsx

---

Let's continue reading the file to see how the stats are loaded and displayed:

---

Read file: src/app/page.tsx

---

Let's check the `useSplashStats` hook that seems to be fetching the stats:

---

<details>
            <summary>Searched codebase "useSplashStats" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Let's read the useSplashStats hook:

---

Read file: src/lib/hooks/useSplashStats.ts

---

Now let's check how the API endpoint for public stats is implemented:

---

<details>
            <summary>Searched codebase "api/opportunities/public-stats" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Let's read the API route implementation:

---

Read file: src/app/api/opportunities/public-stats/route.ts

---

Let's also check how the stats are displayed on the main page:

---

Read file: src/app/page.tsx

---

Now, let's look for where the HeroSection component uses the stats:

---

Read file: src/app/page.tsx

---

Let's also look at the actual HeroSection to see how it displays the stats:

---

Read file: src/app/page.tsx

---

Let's continue the HeroSection component to see where the stats are displayed:

---

Read file: src/app/page.tsx

---

Let's see how each stat is rendered:

---

Read file: src/app/page.tsx

---

Based on this exploration, I now have a good understanding of how the public stats are implemented. Let me analyze the potential sources of the problem where stats are sometimes shown as 0 in production but work fine locally.

Here are 5-7 possible sources of the problem:

1. **Firebase Initialization Timing Issue**: In the `public-stats/route.ts` file, there's a check to see if Firebase is initialized. If it's not initialized yet when the API is called, it returns default values (all 0). It's possible that in production, the timing of Firebase initialization is different, causing this check to sometimes fail.

2. **Caching Issues**: The API route has caching headers (`'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60'`). This could be causing stale data to be served sometimes, and the caching behavior might be different in production vs. local development.

3. **Query Timeout Issue**: The API has a 5-second timeout. If Firestore queries are slower in production than locally, they could be timing out occasionally, resulting in default values being returned.

4. **React Query Cache Behavior**: The `useSplashStats` hook uses react-query with specific caching settings (staleTime, gcTime). There could be issues with how react-query is managing the cache in production.

5. **Firestore Permissions**: It's possible that there are occasional permission issues with Firestore in production that don't occur locally, causing queries to fail.

6. **Network Latency/Reliability**: In production, network requests to Firestore might occasionally fail or be unreliable due to latency or connectivity issues.

7. **Firebase Admin Credential Issues**: The Firebase admin initialization uses credentials from environment variables. If there's an issue with these credentials in production (perhaps they're occasionally unavailable or invalid), it could cause Firebase initialization to fail.

Based on these possibilities, the most likely sources of the problem are:

1. **Firebase Initialization Timing Issue**: This is most likely because the code explicitly returns zeros when Firebase isn't initialized. The check `if (getApps().length === 0)` could sometimes evaluate to true in production due to timing differences.

2. **Caching Issues**: Given that you see inconsistent behavior (sometimes 0, sometimes correct), this strongly suggests a caching problem where stale data is being served.

Let's add logging to validate these assumptions. I'll add logs to the API route to track:
1. Whether Firebase is initialized
2. What data is being returned
3. Timing information

---

```diff
  
  export async function GET() {
-   console.log('Public stats endpoint called');
+   const requestStart = Date.now();
+   console.log('[PUBLIC-STATS] API endpoint called at', new Date().toISOString());
+   console.log('[PUBLIC-STATS] Firebase apps initialized:', getApps().length);
  
    try {
      const controller = new AbortController();
-     const timeoutId = setTimeout(() => controller.abort(), 5000);
+     const timeoutId = setTimeout(() => {
+       console.log('[PUBLIC-STATS] Request timed out after 5000ms');
+       controller.abort();
+     }, 5000);
  
      try {
        // Check if Firebase is properly initialized
        if (getApps().length === 0) {
-         console.warn('Firebase not initialized, returning default values');
+         console.warn('[PUBLIC-STATS] Firebase not initialized, returning default values');
          return NextResponse.json(
            {
              averageValue: 0,
              lastUpdated: new Date().toISOString(),
+             debug: {
+               firebaseInitialized: false,
+               requestDuration: Date.now() - requestStart,
+               timestamp: Date.now(),
+             }
            },
            {
              status: 200,
              headers: {
                'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60',
+               'X-Debug-Firebase-Initialized': 'false',
              },
            }
          );
        }
  
-       console.log('Firebase initialized, fetching stats');
+       console.log('[PUBLIC-STATS] Firebase initialized, fetching stats');
+       const dbStart = Date.now();
        const db = getFirestore();
        const opportunitiesSnapshot = await db
          .collection('opportunities')
          .where('status', '==', 'approved')
          .get();
+       const dbDuration = Date.now() - dbStart;
+       console.log(`[PUBLIC-STATS] Firestore query completed in ${dbDuration}ms`);
  
        // Initialize counters
        });
  
-       console.log(`Found ${activeCount} active opportunities`);
+       console.log(`[PUBLIC-STATS] Found ${activeCount} active opportunities with total value ${totalValue}`);
        const averageValue = activeCount > 0 ? Math.round(totalValue / activeCount) : 0;
  
+       const totalDuration = Date.now() - requestStart;
        const result = {
          activeCount,
          totalPotentialValue: totalValue,
          averageValue,
          lastUpdated: new Date().toISOString(),
-       };
+         debug: {
+           firebaseInitialized: true,
+           requestDuration: totalDuration,
+           dbQueryDuration: dbDuration,
+           timestamp: Date.now(),
+         }
+       };
+ 
+       console.log(`[PUBLIC-STATS] Returning result:`, JSON.stringify(result));
+       console.log(`[PUBLIC-STATS] Total request duration: ${totalDuration}ms`);
  
        return NextResponse.json(result, {
          status: 200,
          headers: {
            'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60',
+           'X-Debug-Firebase-Initialized': 'true',
+           'X-Debug-Request-Duration': totalDuration.toString(),
          },
        });
      }
    } catch (error) {
-     console.error('Public stats endpoint error:', error);
+     const errorDuration = Date.now() - requestStart;
+     console.error(`[PUBLIC-STATS] Error after ${errorDuration}ms:`, error);
      if (error instanceof Error) {
-       console.error('Error details:', error.message);
-       if (error.stack) console.error('Stack:', error.stack);
+       console.error('[PUBLIC-STATS] Error details:', error.message);
+       if (error.stack) console.error('[PUBLIC-STATS] Stack:', error.stack);
      }
  
      if (error instanceof Error && error.name === 'AbortError') {
-       return NextResponse.json({ error: 'Stats request timed out' }, { status: 504 });
+       return NextResponse.json({ 
+         error: 'Stats request timed out',
+         debug: {
+           firebaseInitialized: getApps().length > 0,
+           requestDuration: errorDuration,
+           timestamp: Date.now(),
+         }
+       }, { status: 504 });
      }
  
-     return NextResponse.json({ error: 'Failed to fetch statistics' }, { status: 500 });
+     return NextResponse.json({ 
+       error: 'Failed to fetch statistics',
+       debug: {
+         firebaseInitialized: getApps().length > 0,
+         errorMessage: error instanceof Error ? error.message : 'Unknown error',
+         requestDuration: errorDuration,
+         timestamp: Date.now(),
+       }
+     }, { status: 500 });
    }
  }
```

---

Now, let's also add some logging to the useSplashStats hook to track when it's fetching data and what it's getting back:

---

```diff
    // Metadata
    lastUpdated: string;
+   debug?: {
+     firebaseInitialized: boolean;
+     requestDuration: number;
+     dbQueryDuration?: number;
+     timestamp: number;
+   };
  }
  
  const fetchStats = async (): Promise<OpportunityStats> => {
+   console.log('[CLIENT] Fetching public stats at', new Date().toISOString());
+   const fetchStart = Date.now();
+   
    const response = await fetch('/api/opportunities/public-stats', {
      next: { revalidate: 300 }, // Cache for 5 minutes
    });
-   if (!response.ok) throw new Error('Failed to fetch stats');
-   return response.json();
+   
+   const fetchDuration = Date.now() - fetchStart;
+   console.log(`[CLIENT] Fetch completed in ${fetchDuration}ms, status: ${response.status}`);
+   
+   if (!response.ok) {
+     const errorText = await response.text();
+     console.error(`[CLIENT] Fetch error: ${response.status}`, errorText);
+     throw new Error(`Failed to fetch stats: ${response.status}`);
+   }
+   
+   const data = await response.json();
+   console.log('[CLIENT] Received stats data:', JSON.stringify(data));
+   return data;
  };
  
      gcTime: 1000 * 60 * 10, // 10 minutes
      select: (stats) => {
+       console.log('[CLIENT] Processing stats data in select:', JSON.stringify(stats));
+       
        // Ensure we have valid numbers before formatting
        const potentialValue =
            : formatCurrency(stats.averageValue || 0);
  
-       return [
+       const formattedStats = [
          {
            label: 'POTENTIAL BONUS EARNINGS',
          },
        ];
+       
+       console.log('[CLIENT] Formatted stats:', JSON.stringify(formattedStats));
+       return formattedStats;
      },
      retry: 2,
      refetchOnWindowFocus: true,
    });
+ 
+   if (error) {
+     console.error('[CLIENT] Error in useSplashStats hook:', error);
+   }
  
    return {
```

---

Let's add one more set of logs to the HeroSection component in the main page to track when and how it's displaying the stats:

---

```diff
    const theme = useTheme();
    const { user } = useAuth();
-   const { stats, error: statsError } = useSplashStats();
+   const { stats, error: statsError, isLoading } = useSplashStats();
    const [opportunities, setOpportunities] = useState<FirestoreOpportunity[]>([]);
-   const [isLoading, setIsLoading] = useState(true);
+   const [isOpportunitiesLoading, setIsOpportunitiesLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
+ 
+   // Log stats whenever they change
+   useEffect(() => {
+     console.log('[HOMEPAGE] Stats received:', JSON.stringify(stats));
+   }, [stats]);
  
    useEffect(() => {
      const fetchFeaturedOpportunities = async () => {
        try {
-         setIsLoading(true);
+         setIsOpportunitiesLoading(true);
          const response = await fetch('/api/opportunities/featured');
          if (!response.ok) {
          setError('Failed to load opportunities');
        } finally {
-         setIsLoading(false);
+         setIsOpportunitiesLoading(false);
        }
      };
    useEffect(() => {
      if (statsError) {
+       console.error('[HOMEPAGE] Stats error:', statsError);
        setErrorMessage('Failed to load statistics. Please try again later.');
      }
        <HeroSection user={user} stats={stats || []} />
        <Box sx={{ py: 8 }}>
-         {isLoading ? (
+         {isOpportunitiesLoading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
              <CircularProgress />
```

---

Now, let's commit these changes so we can track them in our branch:

---

```bash
git add . && git commit -m "Add extensive logging to diagnose inconsistent public stats issue"
```

```
<logging to diagnose inconsistent public stats issue" 
[fix-inconsistent-public-stats 1a56e5f] Add extensive logging to diagnose inconsistent public stats issue
 6 files changed, 507 insertions(+), 18 deletions(-)
 create mode 100644 .cursor/rules/derived-cursor-rules.mdc
 create mode 100644 .specstory/.what-is-this.md
 create mode 100644 .specstory/history/2025-03-14_17-30-untitled.md
?➜  churnistic git:(fix-inconsistent-public-stats) ?✗
```

---

## Summary of Diagnosis and Next Steps

Based on my investigation, here are the likely sources of the inconsistent public stats issue and the approach we've taken:

### Potential Sources of the Problem (5-7 possibilities):

1. **Firebase Initialization Timing Issue**: The API checks `if (getApps().length === 0)` and returns zeros if Firebase isn't initialized. This could be happening in production due to different timing.

2. **Caching Issues**: Both the API and client use caching mechanisms (`Cache-Control` headers, React Query stale times) that could be serving stale or inconsistent data.

3. **Query Timeout Issue**: The API has a 5-second timeout that might be triggering in production, causing default values to be returned.

4. **React Query Cache Behavior**: The caching behavior in React Query could be different in production vs. development.

5. **Firestore Permissions**: Potential intermittent permission issues in production.

6. **Network Latency/Reliability**: Production might have intermittent network issues when connecting to Firestore.

7. **Firebase Admin Credential Issues**: Possible intermittent credential availability in production environment.

### Most Likely Sources:

1. **Firebase Initialization Timing Issue**: This seems most likely since the code explicitly returns zeros when Firebase isn't properly initialized.

2. **Caching Issues**: The inconsistent behavior (sometimes working, sometimes not) strongly suggests caching problems.

### Added Logging to Validate Assumptions:

I've added extensive logging at three critical points:

1. **API Endpoint** (`public-stats/route.ts`):
   - Logs when the endpoint is called
   - Logs Firebase initialization state
   - Tracks timing for database queries and overall request
   - Adds debugging information to responses and headers
   - Enhanced error reporting

2. **Client-Side Hook** (`useSplashStats.ts`):
   - Logs when stats are fetched and what data is received
   - Tracks timing for API requests
   - Enhanced error reporting
   - Logs data transformation steps

3. **Main Page** (`page.tsx`):
   - Logs when stats are received and used for rendering
   - Improved error handling

### Next Steps:

1. **Deploy these changes** to production to collect logs that will help identify the root cause.

2. **Analyze the logs** to understand:
   - Is Firebase consistently initialized when the API is called?
   - Are there timing issues with Firestore queries?
   - Is caching working as expected?
   - Are there any errors that only occur in production?

3. **Implement a fix** based on the log analysis. Potential fixes could include:
   - Ensuring Firebase is fully initialized before handling requests
   - Adjusting caching strategies
   - Implementing retry mechanisms
   - Extending timeouts

Would you like to deploy these changes to collect the logs, or would you prefer to discuss potential fixes based on the analysis so far?

---

_**User**_

[HOMEPAGE] Stats received: [{"label":"POTENTIAL BONUS EARNINGS","value":"$56,548.00","description":"Total value of all active bonus opportunities"},{"label":"BONUSES AVAILABLE","value":"346+","description":"Number of active bonus opportunities"},{"label":"AVERAGE BONUS VALUE","value":"$163.00","description":"Average value per bonus opportunity"}]

going to try on the domain and report back, this is in local

---

_**Assistant**_

<think>The user has shared a log message from their local environment showing what the stats values look like when running locally. The log is coming from the code we added to track when stats are received in the HomePage component. The stats look good locally, showing:

1. POTENTIAL BONUS EARNINGS: $56,548.00
2. BONUSES AVAILABLE: 346+
3. AVERAGE BONUS VALUE: $163.00

The user is going to try on the production domain (churnistic.com) and report back. They're following our suggested approach of checking the logs to see where the differences might be between local and production environments.

Let me wait for their update after they test on the production domain. With our extensive logging in place, we should be able to compare the logs between local and production to identify where the discrepancy occurs.</think>Thanks for sharing the local stats output! This is excellent - it confirms that locally your stats are being properly loaded and formatted:

- POTENTIAL BONUS EARNINGS: $56,548.00
- BONUSES AVAILABLE: 346+
- AVERAGE BONUS VALUE: $163.00

This local data looks correct and matches what we'd expect to see. With the extensive logging we've added, we'll be able to compare what's happening in production vs. locally once you check the domain and report back.

When you test on churnistic.com, pay particular attention to:

1. Whether you see zeroes or the correct values
2. If any error messages appear in the browser console 
3. If the values flicker between zeroes and correct values (which would strongly suggest a caching issue)

The logs we've added will help pinpoint exactly where in the process things might be going wrong in production. I'll wait for your report from the production environment to continue our investigation.

---



---

